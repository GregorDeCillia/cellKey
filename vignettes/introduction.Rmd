---
title: "Introduction to the cellKey-Package"
author: "Bernhard Meindl"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
  toc: true
toc_depth: 5
number_sections: false
vignette: >
  %\VignetteIndexEntry{Introduction to the cellKey-Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

  ```{r, echo=FALSE}
library(rmarkdown)
```

# Introduction

This package implements methods to provide perturbation for statistical tables. The method is based on the paper *Methodology for the Automatic Confidentialisation of Statistical Outputs from Remote Servers at the Australian Bureau of Statistics* (Thompson, Broadfoot, Elazar). Furthermore it is possible to perturb tables using a different approach developed by the Federal Statistical Office of Germany (Destatis). The two approaches differ in the way record keys have to be specified, the format of the perturbation tables and the way, the actual lookup is done. Perturbation tables need to be specified using functionality from package [**ptable**](https://github.com/sdcTools/ptable).

## Main Features


In the **cellKey** package it is possible to make use of two different ways on how to pertub multidimensional count tables - methods `abs` and `destatis`. For both of them methods are provided to generate suitable record keys using function `ck_generate_rkeys()`. For the perturbation of magnitude tables, for now only the method developed by the ABS is supported. Using sha1-checksums on the input datasets, we can make sure that the same record keys are generated whenever the same input data set is used for which record keys should be generated. However, it is also possible of course to use already pre-generated record keys available as variable in the microdata set.

The package allows to make use of sampling weights. Thus, both weighted and unweighted count and magnitude tables can be perturbed. The hierarchical structure of the variables spanning the table can be arbitrarily complex. To generate these hierarchies, the **cellKey** packages imports functionality from the [**sdcHierarchies**](https://cran.r-project.org/package=sdcHierarchies) package that allows to define these hierarchies in an intuitive way. Finally, auxiliary methods are provided that allow to extract valueable information from objects created by the main function of this package `perturb_table()`. For example `mod_counts()` returns a data object showing for each cell the perturbation value and where it was found in the lookup table.

What is left is of course identifying bugs and issues and also to optimize performance of the package as well as to include some real world examples, eg. census tables.

## An Example

### Load the Package
```{r}
library(cellKey)
packageVersion("cellKey")
```

### Loading testdata
The testdata set we are using in this example contains information on person-level along with sampling weights as well as some categorical and continuously scaled variables. We also compute some binary variables for which we also want to create perturbed tables.

```{r}
dat <- ck_create_testdata()[,c("sex", "age", "savings", "income", "sampling_weight")]
dat[, cnt_males := ifelse(sex == "male", 1, 0)]
dat[, cnt_highincome := ifelse(income >= 9000, 1, 0)]
```

The goal of this introduction is to create a perturbed table of counts of variables `sex` by `age` for all observations as well as for the subgroups in `cnt_males` and `cnt_highincome` that are non-zero. We also want to create perturbed tables of continously scaled variables `savings` and `income` also giving the hierarchical structure defined by `sex` by `age`.

### Create required input
The first step in this approach is to generate or rather set some parameters that are using in the perturbation approach. These inputs are put together using function `ck_create_pert_params()`. 

```{r}
pert_params <- ck_create_pert_params(
  big_n = 17312941,
  small_n = 12,
  ptab = ck_create_ptab(
    D = 5,
    V = 3,
    ptab_size = 70,
    type = "abs"
  ),
  stab = ck_generate_stab(small_c = 12),
  mtab = c(0.6, 0.4, 0.2)
)
```

The parameters that have to be specified are:

- `big_n`: a large prime number used to derive cell keys from record keys
- `small_n`: a number that controls how the columns of a perturbation table are scrolled
- `ptab`: a perturbation table containing perturbation values. Function `ck_create_ptab(type  = "destatis", ...)` returns an exemplary perturbation table in `abs` format given a flexible number of columns (specified using parameter `ptab_size`) and a fixed (256) number of rows. An alternative way to specify perturbation tables was proposed by DESTATIS. Perturbation tables in this format can be generated by using functionality from the [**ptable**](https://github.com/sdcTools/ptable) package using `ptable::pt_create_pTable()`. If such an input is used, parameters `big_n` and `small_n` are ignored because they are not needed in the algorithm to lookup perturbation values.
- `stab`:  a table containing the noise component for numerical variables that must contain 32 + `small_c` columns. An example table may be generated using function `ck_generate_stab()`
- `mtab`: a numeric vector containing parameters for the magnitude of perturbation for numerical variables

This function returns an object of class `pert_params` that is required in the next function that must be called. In `ck_create_input()` we finally create the required input to be able to compute some perturbed tables as follows.

```{r}
inp <- ck_create_input(
  dat = dat, 
  def_rkey = 15 * nrow(dat), 
  pert_params = pert_params)
print(class(inp))
```

We needed to specify parameter `def_rkey`. In this argument, users may either specify an (existing) variable name in the input microdata set `data` that already contains record keys or specify a number. In the second case, the functions computes record keys based on the format of the perturbation table (slot `ptab` in argument `pert_params`). If the perturbation table is in abs-format, record keys between 1 and `def_key` are randomly computed. In case the perturbation table is in destatis-format, the record keys are sampled from a uniform distribution between 0 and 1 and rounded to the number of digits specified in parameter `def_rkey`. 

To ensure that the same record keys are computed each and every time for the same data set, a seed based on the sha1-hash of the input dataset is computed and used before drawing the record keys.

### Specifying dimensions
The next step is to define hierarchies for each of the classifying variables. **cellKey** requires that the dimensions are specified by using functionality from package [**sdcHierarchies**](https://cran.r-project.org/package=sdcHierarchies). The vignette of this package that shows how to use this package can be [**accessed online**](https://bernhard-da.github.io/sdcHierarchies/articles/usage.html). The main functions required to define a hierarchy are `hier_create()`, `hier_add()` and `hier_delete()`. We now show how to create the two hierarchies for the categorical variables `age` and `sex`:

```{r}
dim_sex <- hier_create(root = "Total", nodes = c("male", "female"))
hier_display(dim_sex)

dim_age <- hier_create(root = "Total", nodes = paste0("age_group", 1:6))
hier_display(dim_age)
```

The idea is to create a tree object using `hier_create()` and then add (using `hier_add()`) or delete (using `hier_delete()`) elements from this hierarchical structure. All hierarchy specifications must then be combined into a named list where the names of the list refer to variable names of the input data set and the elements are data objects created above that contain the hierarchy specification. This is why the list elements of `dim_list` have to be named `sex` and `age`.

```{r}
dl <- list(sex = dim_sex, age = dim_age)
print(dl)
```

### Compute perturbed tables
It is now possible to finally compute perturbed tables using function `perturb_table()`. This function takes the following parameters:

- `inp`: required, an object of class `pert_input` created with `ck_create_input()`
- `dim_list`: required, a `list` containing definitions of hierarchies of all variables that will define the table
- `weightVar`: optional, a variable name existing in `slot(inp, "microdat)` holding sampling weights for each unit in the micro data or or `NULL` if no weights are available. In this case, each unit is assigned sampling weight 1 in the data
- `countVars`: optional, a vector of variable names existing in `slot(inp, "microdat)` that should be perturbed. The key is that these variables need to be binary (0/1 coded).
- `numVars`: optional, a vector of variable names existing in the input microdata that should be tabulated (and perturbed). 

If both `countVars` and `numVars` are not specified, the perturbed count table based on all units is computed. Below it is shown, how a count table using existing sampling weights (available in variable `sampling_weight` in the input data) can be computed:

```{r}
tab1 <- perturb_table(
  inp = inp,
  dim_list = dl,
  countVars = c("cnt_males", "cnt_highincome"),
  weightVar = "sampling_weight",
  numVars = NULL
)
print(tab1) # custom print method
# print(tab1, vname="Total")
```

Applying method `ck_freq_table()` to an output object of `perturb_table()` returns a `data.table` with all combinations of the dimensional variables `sex` and `age` as well as original and perturbed (un)weighted values are returned. In any case, the tabulation of all observations can be extracted (`vnames="Total"`). If additional variables have been specified in argument `countVars`, these can be queried too as shown below:

```{r}
ck_freq_table(tab1) # show which tables have been generated
ck_freq_table(tab1, vname = "cnt_males")
```

In the example above we see, that all cells containing `sex=="female" no perturbation has been applied. The variables on this data set (additional to the dimensional variables) are:

- `UWC`: unweighted counts
- `pUWC`: perturbed unweighted counts
- `WC`: weighted counts
- `pWC`: perturbed weighted counts
- `WCavg`: cell average weight

Function `ck_cnt_measures()` applied to the resulting object of `perturb_table()` allows to compute information loss measures for perturbed count variables. Its application is as simple as:

```{r}
infoloss <- ck_cnt_measures(tab1, vname = "Total")
```

This function returns a list with the following elements:

- **measures:** a data.table containing measures of the distribution of three different distances between original and perturbed values of the unweighted counts. The three distances are
    - absolute distance (column vals_abs), *d1*
    - relative distance (column vals_rel), *d2*
    - absolute distance between square-roots of original and perturbed values (column vals_r), *d3*
- **cum_distr_a:** a data.table showing the cumulative sum and proportion for distance *d1*
- **cum_distr_b:** a data.table showing the cumulative distributions for distances *d2* and *d3* for a set of intervals.
- **false_zero:** number of cells that were perturbed to zero
- **false_positives:** number of cells that were initially zero but have been perturbed to a number different from zero

The next example shows how to create a perturbed table of continuous data using sampling weights. For this case, we need to specify parameter `numVars` in `perturb_table()`. Note that it is possible, to specify multiple variables at once.

```{r}
tab2 <- perturb_table(
  inp = inp, 
  dim_list = dl,  
  weightVar = "sampling_weight", 
  countVars = c("cnt_males", "cnt_highincome"), 
  numVars = c("savings","income")
)
```

To get information about magnitute tables, function `ck_cont_table()` can be applied to the output of `perturb_table()`. In this case, we can set an additional argument `mean_before_sum` that is either `TRUE` or `FALSE` and specifies, how the perturbed cell values are computed. Details on this method can be found in *Methodology for the Automatic Confidentialisation of Statistical Outputs from Remote Servers at the Australian Bureau of Statistics* (Thompson, Broadfoot, Elazar) in Section *6.3*.

```{r}
p_income <- ck_cont_table(tab2, vname = "income", mean_before_sum = TRUE)
p_income
```

The result obtained from `ck_cont_table` contains an attribute `modification` which holds a `data.table` containing all the perturbations for the variable queried in `vname`. We can access this information as shown below:

```{r}
attr(p_income, "modifications")
```

We see that this `data.table` has the following variables:

- `id`: the id of the observation in the input data set for which values were modified
- `magnitude`: the amount of perturbation
- `dir`: the direction of perturbation, -1 is negative, +1 is positive
- `noise`: the noise term applied 
- `vals.orig`: the original value of the variable
- `vals.pert`: the amount of perturbation (`magnitude * dir * noise * vals.orig`)
- `vals.mod`: the final perturbed value (`vals.orig`+`vals.pert`)

An interesting feature is that one can optionally specify argument `by` in `perturb_table()` which is relevant for the computation of perturbed magnitude tables. The idea is that it allows to compute magnitude tables restricted to some units in the data set. In the following example we show how to create a perturbed table of `savings` for only those observations that have high income (variable `cnt_highincome`).

```{r}
tab3 <- perturb_table(
  inp = inp, 
  dim_list = dl,  
  weightVar = "sampling_weight", 
  numVars = c("savings"), 
  by = "cnt_highincome"
)
```

We note that if the by_variable has been specified, it will be automatically added to `countVars` internally, so we can also use `ck_freq_table()` with the by-variable even it was not explicitely specified in `countVars`.

```{r}
# frequency table of the by-variable
ck_freq_table(tab3, vname = "cnt_highincome")
```

To show the table of variable `savings` we use again `ck_cont_table()`.
 
```{r}
p_savings <- ck_cont_table(tab3, vname = "savings", mean_before_sum = TRUE)
p_savings
```
 
From the results we can observe that there are no high-income units in the highest age group (`age_group6`) and those cells are not perturbed at all.


Using function `ck_export_table()` which can be applied to outputs of `perturb_table()`. This functions returns a simple `data.frames` containing all cells and perturbed (weighted) values for a given perturbed variables. We could apply it to the `Total`-variable as follows

```{r}
dt_tot <- ck_export_table(tab3, vname = "Total", type = "both")
head(dt_tot)
```

### Extract information from results
Some auxiliary methods may be applied to output object of function `perturb_table()`. The structure of such objects is shown below:

```{r}
slotNames(tab2)
```

Information on perturbations for counts can be extracted using `mod_counts()`. The method returns a `data.table` showing for each cell and tabulated variable the row and the column of the perturbation table that was used to find the perturbation value actually used. This value is also shown in the output.
```{r}
head(mod_counts(tab2))
```

Information on perturbations for numerical variables can be extracted using `mod_numvars()`. This \code{data.table} contains the ids of the observations of the input variables that have been modified. For each observation and tabulated numerical variable (given in `numVar`), the parameters used in modifying (direction, magnitude and noise) are shown as well as the original values, the perturbation and the final modified value. These values were finally used to compute the tables itself.
```{r}
head(mod_numvars(tab2))
```

Finally we note that there are `print` and `summary` methods implemented for objects returned from `perturb_table()` which can be used as shown below:

```{r}
print(tab1)
print(tab1, vname = "Total")
summary(tab1)
```

## Summary
In case you have any suggestions or improvements, please feel free to file an issue at [**our issue tracker**](https://github.com/sdcTools/cellKey/issues) or contribute to the package by filing a [**pull request**](https://github.com/sdcTools/cellKey/pulls) against the master branch.
