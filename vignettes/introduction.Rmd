---
title: "Introduction to the cellKey-Package"
author: "Bernhard Meindl"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
  toc: true
toc_depth: 5
number_sections: false
vignette: >
  %\VignetteIndexEntry{Introduction to the cellKey-Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

  ```{r, echo=FALSE}
library(rmarkdown)
```

# Introduction

This package implements methods to provide perturbation for statistical tables. The implementation if greatly inspired by the the paper *Methodology for the Automatic Confidentialisation of Statistical Outputs from Remote Servers at the Australian Bureau of Statistics* (Thompson, Broadfoot, Elazar). This approach however was generalized and a new specification on how record keys are specified and the lookup-tables are defined is used. This package makes usage of perturbation tables that can be defined in the [**ptable**](https://github.com/sdcTools/ptable) package. This document describes the usage of version ``r packageVersion("cellKey")`` of the package.

## Installation
Package [**cellKey**](https://github.com/sdcTools/cellKey) is not yet on `CRAN` and thus needs to be installed from source. The following code gives instructions on how to install the latest version of the package directly from [**github.com**](https://www.github.com):

```{r, eval = FALSE}
# update your R installation
update.packages(ask = FALSE)

# install cellKey from github.com
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}
remotes::install_github(
  repo = "sdcTools/cellKey",
  dependencies = TRUE,
  build_opts = "--no-resave-data",
  force = TRUE
)
```

## Main Features
In the **cellKey** package it is possible to pertub multidimensional count and magnitude tables. Functionality to generate suitable record keys is provided in function `ck_generate_rkeys()`. Using sha1-checksums on the input datasets, we can make sure that the same record keys are generated whenever the same input data set is used for which record keys should be generated. However, it is also possible of course to use already pre-generated record keys available as variable in the microdata set.

The package allows to make use of sampling weights. Thus, both weighted and unweighted count and magnitude tables can be perturbed. The hierarchical structure of the variables spanning the table can be arbitrarily complex. To generate these hierarchies, the **cellKey** packages depends on functionality available in package [**sdcHierarchies**](https://cran.r-project.org/package=sdcHierarchies). Finally, auxiliary methods are provided that allow to extract valueable information from objects created by the main function of this package `perturbTable()`. For example `mod_counts()` returns a data object showing for each cell the perturbation value and where it was found in the lookup table.

What is left is of course identifying bugs and issues and also to optimize performance of the package as well as to include some real world examples, eg. census tables.

## An Example
We now show the capabilities of the **cellKey** package by running an example that 

### Load the Package
```{r, include = FALSE, echo = TRUE}
library(cellKey)
packageVersion("cellKey")
```

```{r, echo = TRUE}
library(cellKey)
packageVersion("cellKey")
```



The first step in this approach is to generate a statistical table, which can be achieved using `ck_setup`. This function generates an object that contains all the information required to perturb count- (and optionally continuously scaled) variables. There are however a few inputs that `ck_setup()` requires and that need to be generated beforehand. These inputs are:

- `x`: a `data.frame` or `data.table` containing microdata
- `rkey`: defines where to find or how to compute record keys. It is possible to either specify a scalar character name or a number. If a number is specified, record keys are internally created by sampling from a uniform distribution between 0 and 1 with the random numbers rounded to the specified value of digits. If a name is specified, this name is interpreted as a variable name within `x` already containing record keys.
- `dims`: a named list where each list element contains a hierarchy created with functionality from package [**sdcHierarchies**](ttps://cran.r-project.org/package=sdcHierarchies) and each name refers to a variable in `x`
- `w`: either `NULL` (no weights) or the name of a variable in `x` that contains weights
- `countvars`: an optional character vector of variables in `x` holding counts. In any case a special count variable `total` is internally generated that is `1` for each row of `x`
- `numvars`: an optional character vector of variables in `x` holding numerical variables that can later be perturbed.

```{r, echo = FALSE}
# additional parameters for ck_setup()
#- `params_cnts`: an object containing perturbation parameters relevant to `countvars` that needs to be created using `ck_params_cnts()`.
#- `params_nums`: if `numvars` was specified, an object containing perturbation parameters relevant to `numvars` that must to be #created using `ck_params_nums()`.
```

We now show how to generate the required inputs. The first step is to prepare the inputdata.

### Specifying inputdata
The testdata set we are using in this example contains information on person-level along with sampling weights as well as some categorical and continuously scaled variables. We also compute some binary variables for which we also want to create perturbed tables. 
```{r}
dat <- ck_create_testdata()
dat <- dat[, c("sex", "age", "savings", "income", "sampling_weight")]
dat[, cnt_males := ifelse(sex == "male", 1, 0)]
dat[, cnt_highincome := ifelse(income >= 9000, 1, 0)]
```

We are now adding record keys with 7 digits to the data set that are going to be used later using function `ck_generate_rkeys` as shown below:

```{r}
dat$rkeys <- ck_generate_rkeys(dat = dat, nr_digits = 7)
print(head(dat))
```

To ensure that the same record keys are computed each and every time for the same data set, a seed based on the sha1-hash of the input dataset is computed and used before drawing the record keys.

The goal of this introduction is to create a perturbed table of counts of variables `sex` by `age` for all observations as well as for the subgroups in `cnt_males` and `cnt_highincome` that are non-zero. We also want to create perturbed tables of continously scaled variables `savings` and `income` also giving the hierarchical structure defined by `sex` by `age`.

### Specifying dimensions
It is required to define hierarchies for each of the classifying variables of the desired table. There are two ways how the hierarchical structure of these variables (including sub-totals) can be specified. One way is to use `"@; value` format as (also) used in [**sdcTable**](ttps://cran.r-project.org/package=sdcTable). We would suggest however, to use the second alternative which is using functionality from package [**sdcHierarchies**](ttps://cran.r-project.org/package=sdcHierarchies). In this vignette, we only show the preferred way to generate hierarchies for categorical variables `age` and `sex` below:

```{r}
dim_sex <- hier_create(root = "Total", nodes = c("male", "female"))
hier_display(dim_sex)
```

For variable `age` the process is very much the same:
```{r}
dim_age <- hier_create(root = "Total", nodes = paste0("age_group", 1:6))
hier_display(dim_age)
```

The idea of [**sdcHierarchy**](https://github.com/bernhard-da/sdcHierarchies) is to create a tree object using `hier_create()` and then add (using `hier_add()`), delete (with `hier_delete()`) or rename (using `hier_rename()`) elements from this hierarchical structure. For more examples have a look at the package vignette of the package which can be accessed with `sdcHierarchies::hier_vignette()`. [**sdcHierarchy**](https://github.com/bernhard-da/sdcHierarchies) also contains a shiny-based app that can be called with `hier_app()` which allows to interactively change and modify a hierarchy and allows to convert tree- and data.frame based inputs into various formats. For more information, have a look at `?hier_app` and the other help-files of the package.

After all dimensions have been specified, these inputs must then be combined into a named list. In this object, the list-names refer to variable names of the input data set and the elements the data objects that hold the hierarchy specification itself. This is why the list elements of `dims` in this example have to be named `sex` and `age` as the specification refers to variables `age` and `sex` in input set `dat`.

```{r}
dims <- list(sex = dim_sex, age = dim_age)
```

### Setup a table instance
We now have prepared the inputs and can define a generic statistical table using `ck_setup()` as shown below:

```{r}
tab <- ck_setup(
  x = dat,
  rkey = "rkeys",
  dims = dims,
  w = "sampling_weight",
  countvars = c("cnt_males", "cnt_highincome")
)
```

`ck_setup()` returns a `R6` class object that contains not only the relevant data but also all available methods. Thus, it is not required to assign the results of such methods to new objects, instead, the object itself is automatically updated.

These objects also have a custom print method, showing some general information about the object:

```{r}
print(tab)
```

### Define perturbation parameters for count variables
The next task is to define parameters that are used to perturb count variables which can be archieved using function `ck_params_cnts`. This function wraps `pt_create_pTable` from the [**ptable**](https://github.com/sdcTools/ptable) package, so for the parameters have a look at the help page for this function. A typical application is shown below:

```{r}
# two different perturbation parameter sets
p_cnts1 <- ck_params_cnts(
  D = 5,
  V = 3,
  js = 2,
  pstay = 0.5,
  optim = 1,
  mono = TRUE)
tab$params_cnts_set(val = p_cnts1, v = "total")

# create alternative perturbation parameters
p_cnts2 <- ck_params_cnts(
  D = 8,
  V = 3,
  js = 2,
  pstay = 0.5,
  optim = 1,
  mono = TRUE)
```

The output of `ck_params_cnts` is an object that can be directly used in method `params_cnts_set()` as it is now shown:


```{r}
# use `p_cnts1` for variable "total" (which always exists)
tab$params_cnts_set(val = p_cnts1, v = "total")

# use `p_cnts2` for all other variables
tab$params_cnts_set(val = p_cnts2, v = c("cnt_males", "cnt_highincome"))
```

Modifying perturbation parameters for specfic variables is easy, too. It is only required to apply the `params_cnts_set()`-method again.

```{r}
# use `p_cnts1` for variable "cnt_highincome" (replacing previously set values)
tab$params_cnts_set(val = p_cnts1, v = "cnt_highincome")
```

### Define perturbation parameters for continuous variables
Future versions of `cellKey` will allow to perturb continuous variables as well. This is however not yet implemented.


### Compute perturbed tables
It is now possible to finally perturbed variables using the `perturb()`-method. As `tab` - the object created with `ck_setup()` - already contains all possible data, the only required input is the name of a variable that should be perturbed.

- `v`: a character vector specifying one or more variables that should be perturbed.

```{r}
tab$perturb(v = "total")
```

After this call, object `tab` is updated and contains now also perturbed values for variable `total`. We note that no explicit assignment is required.

```{r}
tab$perturb(v = "cnt_males")
```

A `data.table` containing original and perturbed values can now be extracted using the `freqtab()`-method as discussed next.

### Extract perturbed tables
Applying the `freqtab()`-methods to one ore more already perturbed variables returns a `data.table` that contains for each table cell the unpertubed and perturbed (weighted and/or unweighted) counts. This function has the following arguments:

- `v`: one or more variable names of already perturbed count variables
- `type`: a scalar character defining what variables should be included in the result. Possible choices are `"both"` (the default), `"weighted"` and `"unweighted"` 
- `path`: if not `NULL`, a (relative or absolute) path to which the resulting output table should be written. A `csv` file will be generated and `.csv` will be appended to the value provided.

The method returns a `data.table` with all combinations of the dimensional variables in the first $n$ colums and after those, all (or some) of the following columns:

- `vname`: name of the perturbed variable (always included)
- `uwc`: unweighted counts (if `type` is `"both"` or `"unweighted"`)
- `wc`: weighted counts (if `type` is `"both"` or `"weighted"`)
- `puwc`: perturbed unweighted counts (if `type` is `"both"` or `"unweighted"`)
- `pwc`: perturbed weighted counts (if `type` is `"both"` or `"weighted"`)

```{r}
tab$freqtab(v = "total", type = "both")
```

To query only the weighted unperturbed and perturbed counts for `total` and `cnt_males`, one could use the following code:

```{r}
tab$freqtab(v = "total", type = "weighted")
```


### Computing utility measures for count variables
Method `measures_cnts()` allows to compute information loss measures for perturbed count variables. Its application is as simple as:

```{r}
tab$measures_cnts(v = "total", exclude_zeros = TRUE)
```

This function returns a list with several utility measures that are now discussed. For further information have a look at `?ck_cnt_measures` as the same set of measures can also be computed for two vectors containing original and perturbed values.


- `overview`: a `data.table` with the following three columns:
    * noise: amount of noise computed as orig - pert
    * cnt: number of cells perturbed with the value given in column noise
    * pct: percentage of cells perturbed with the value given in column noise

- `measures`: a `data.table` containing measures of the distribution of three different distances between original and perturbed values of the unweighted counts. Column `what` specifies the computed measure. The three distances considered are:
    * `d1`: absolute distance between original and masked values
    * `d2`: relative absolute distance between original and masked values
    * `d3`: absolute distance between square-roots of original and perturbed values

- `cumdistr_d1`, `cumdistr_d2` and `cumdistr_d3`: for each distance d1, d2 and d3, a data.table with the following three columns:
    * `cat`: a specific value (for d1) or interval (for distances d2 and d3)
    * `cnt`: number of records smaller or equal the value in column cat for the given distance
    * `pct`: proportion of records smaller or equal the value in column cat for the selected distance

- `false_zero`: number of cells that were perturbed to zero
- `false_nonzero`: number of cells that were initially zero but have been perturbed to a number different from zero

If argument `exclude_zeros` is `TRUE` (the default setting), empty cells are excluded when computing distance-based measures `d1`, `d2` and `d3`.

### Perturbing continuously scaled variables
The perturbation of magnitude tables is currently in development and will be available in future versions of the `cellKey` package.

```{r, echo = FALSE}
#The next example shows how to create a perturbed table of continuous data using sampling weights. We can perturb all variables that #were specified in argument `numvars` when calling `ck_setup()`. Note that it is also possible to specify multiple variables at once.

#```{r, eval = FALSE}
#tab$perturb(v = "income")
#```

#To get information about magnitude tables, method `numtab()` can be used. In this case, we can set an additional argument #`mean_before_sum` that is either `TRUE` or `FALSE` and specifies how the perturbed cell values are computed. Details on this method #can be found in *Methodology for the Automatic Confidentialisation of Statistical Outputs from Remote Servers at the Australian Bureau #of Statistics* (Thompson, Broadfoot, Elazar) in Section *6.3*. All other arguments are identical to method `freqtab()` that was #previously introduced.

#```{r, eval = FALSE}
#p_income <- tab$numtab(v = "income", mean_before_sum = TRUE)
#p_income
#```

### Extract information from results
#Some auxiliary methods may be applied to an object created with `ck_setup()`. For example one can query the applied perturbations for #counts using the `mod_cnts()` method. This returns a `data.table` showing for each cell and tabulated variable the row and the column #of the perturbation table that was used to find the perturbation value actually used. The value itself is also included.

#```{r}
#tab$mod_cnts()
#```

#Information on perturbations for numerical variables can be extracted using `mod_nums()`. This `data.table` contains the ids of the #observations of the input variables that have been modified. For each observation and tabulated numerical variable (given in #`numvars`), the parameters used in modifying (direction, magnitude and noise) are shown as well as the original values, the #perturbation and the final modified value. These values were finally used to compute the tables itself.
#```{r, echo = FALSE}
#message("WRITE METHOD mod_nums()")
#```

#```{r, eval = FALSE}
#tab$mod_nums()
#```
```

Finally we note that there are `print` and `summary` methods implemented for objects created with from `ck_setup()` which can be used as shown below:

The `print()`-method shows the dimension of the table as well as the variables that are (or possibly can be) perturbed. It is also displayed if the table was constructed using weights. 

```{r}
tab$print() # same as (print(tab))
```

The `summary`-method shows some utility statistics for already perturbed variables as shown below:
```{r}
tab$summary()
```

## Summary
The package is *"work in progress"* and therefore, suggestions and/or bugreports are welcome. Please feel free to file an issue at [**our issue tracker**](https://github.com/sdcTools/cellKey/issues) or contribute to the package by filing a [**pull request**](https://github.com/sdcTools/cellKey/pulls) against the master branch.
